# **2. 早わかりGit**

Gitリポジトリを構築するには, 2つの基本的な方法がある. 作業中の成果物にGitを組み込む形で一からリポジトリを作る方法と, 既にあるリポジトリから「クローン」つまりコピーする方法である.

ここでは空のリポジトリから作成する.

## **1. 初期状態のリポジトリを作成する**

例として, ~/test_htmlディレクトリからリポジトリを作り, Gitリポジトリに入れてみる.

~/public_htmlに内容がなければ, そのディレクトリを作り, 簡単な内容でindex.htmlを作る.

    # mkdir ~/test_html
    # cd ~/test_html
    # echo "Hello world!" > index.html

~/test_html, あるいは任意のディレクトリをGitリポジトリとするために, git initを実行する. ただし, このコマンドはカレントディレクトリをGitリポジトリに変換する.

    # git init

ディレクトリに, 空でも沢山のファイルがあっても, Gitリポジトリへ変換する過程は同じである.

ディレクトリがGitリポジトリであることを表すため, `git init`は.gitと呼ばれる隠しディレクトリをプロジェクトの最も上の階層に作る. リビジョン情報はこの.gitディレクトリだけに置かれる.

~/test_htmlディレクトリにあったファイルはGitから触れることはない. Gitは, ~/test_htmlディレクトリを, プロジェクトの作業ディレクトリであるとみなす. 言い換ええると, このディレクトリのファイルを変更するのはあなたである, ということだ. それに対して, .git内に隠されているリポジトリの情報は, Gitによって管理される.

## **2. ファイルをリポジトリに加える**

`git init`により, 新しく空のGitリポジトリが作られる. 内容を管理するには, それを明示的にリポジトリに置かなければならない. 意識的にこのような作業を行うことで, 作業ファイルを重要なファイルから分けることができる.

リポジトリに加えるには, `git add <file>`を行う.

    # git add index.html

`add`によって, index.htmlをリポジトリへ残したいことがGitへ伝わった. ここまでで, index.htmlは単にコミットの前段階として, **ステージされた**だけな状態である.

> **ステージ**(stage): コミットのための段階に登録する

Gitでは, リポジトリが不安定な状態になるのを避けるために, `add`と`commit`の作業に分けている. `add`のような暫定的な関連する段階を重ね, バッチ処理すれば, リポジトリを安定した状態に保つことができる.

`git status`を実行すると, index.htmlが暫定的な状態にあることがわかる.

    # git status

    On branch master

    Initial commit

    Changes to be commited:
      (use "git rm --cached <file>..." to unstage)

        new file: index.html

新しいファイルindex.htmlが, 次のコミットでリポジトリに追加される予定であることが, 報告されている.

各コミットは, 実際のディレクトリやファイルの内容の変更に加え, 変更時のログメッセージやその作成者を含む, 他のメタデータも記録される. 次のような, 完全な`git commit`により, ログメッセージや作成者を指定することができる.

    # git commit -m "text when you commited" --author="name <e-mail>"

ログメッセージはコマンドラインから指定することもできるが, エディタを使って対話的にログメッセージを書く方がより一般的である. これにより, 自分の好きなエディタで, より完全で詳細なログを書くことができる.

Gitは, 作業ディレクトリが**クリーン**であるかどうかも調べて教えてくれる. ここでクリーンとは, 作業ディレクトリの中に, リポジトリにあるものと異なっていたり, リポジトリに存在しないファイルが1つもなかったり, という意味である.

## **3. コミット作成者を設定する**

リポジトリに本格的にコミットし始める前に, 基本的な環境とオプションの設定をしっかり決めておく必要がある. コミット毎に作成者の情報をコマンドラインから指定するのではなく, `git config`コマンドを使って, 情報を設定ファイルに保存するとよい.

    # git config user.name "<name>"
    # git config user.email "<e-mail>"

## **4. さらにコミットする**

さらに変更を加えて, リポジトリに複雑な更新履歴を作る.

index.htmlの中身がHTMLとなるように変更を加えてコミットする.

    <html>
    <body>
    Hello world!
    </body>
    </html>

commitコマンドを行い, エディタが立ち上がったら, ログを入力し, 保存して終了すると, リポジトリには, index.htmlのバージョンが2つ入っていることになる.

## **5. コミットを見る**

一旦リポジトリにコミットさえしさえすれば, 様々な方法でそれを見ることができる. `git log`は, そのリポジトリにおける各コミットの一連の履歴を表示する.

`git log`のエントリは, 最も新しいものから最も古いものへの順で並べられており, 各エントリには, コミットの作成者の名前, メールアドレス, コミットを行った日付, 変更に対するログメッセージ, そしてコミットの内部識別子(ID)が表示されている.

`git show`にコミットIDを指定せずに実行した場合は, 最新のコミットの詳細を表示する.

`git show-branch`というコマンドは, 現在の開発ブランチの簡潔なログを, 一行ずつ出力する.

## **6. コミットの差分を見る**

index.htmlの2つのリビジョン間の違い(差分)を見るには, それぞれのコミットIDを`git diff`へ正確に指定して実行する.

    # git diff <古いバージョンのコミットID> <新しいバージョンのコミットID>

このコマンドを実行することで, 新たに追加された内容の行頭にプラス記号(+), 削除された内容の行頭にマイナス記号(-)が付くようになる.

## **7. リポジトリ内のファイルを削除したり名前を変える**

リポジトリからファイルを削除する方法は, 追加する方法と似ているが, 削除するには`git rm`コマンドを使う. もう必要ないcolumn.htmlというファイルがあるとする.

    # cd ~/test_html
    # ls
    inidex.html column.html

    # git rm column.html
    rm 'column.html'

    # git commit -m "Remove a column"
    Created commit <commit ID>: Remove a column
     0 files changed, 0 insertions(+), 0 deletions(-)
     delete mode 100644 column.html

追加の時と同様, 削除も2段階で行う. `git rm`によってファイルを削除したいと表明し, 更新内容をステージする. そして, `git commit`でその変更をリポジトリに反映する. ここでも, テキストエディタを使い, `-m`オプションを省略することができる.

ファイル名の変更は, `git rm`と`git add`を組み合わせることで, 間接的に実現することができるが, `git mv`を使った方が, 直接変更することができる.

    # mv a.html b.html
    # git rm a.html
    rm 'a.html'
    # git add b.html

前者の方法では, 上記の手順のようになっていたが, `git mv`を使うと次のようになる.

    # git mv a.html b.html

もちろん, どちらの方法で行ってもその後で変更をコミットしなければならない.

## **8. リポジトリのコピーを作る**

~/test_htmlディレクトリにリポジトリを作成したら, `git clone`コマンドによってリポジトリの完全なコピー, つまりクローンを作成できる. この仕組みによって, 世界中の人々が同じファイル上で各自のプロジェクトを進めながら, 互いのリポジトリを同期された状態を保つことができる.

例として, ホームディレクトリにclone_htmlという名前でコピーを作る.

    # cd ~
    # git clone test_html clone_html

2つのリポジトリは, 全く同じオブジェクト, ファイル, ディレクトリを含んでいるが, 微妙に違う点もある. 次のコマンドで違いを調べる.

    # ls -lsa test_html clone_html
    # diff -r test_html clone_html

今回のようにローカルのファイルシステム上で`git clone`を実行すると, `cp -a`や`rsync`を使ったのとよく似た結果となる.

> **rsync**(remote synchronize): ファイルの同期やバックアップに使い, 差分のみコピーする

一度リポジトリをクローンすれば, クローンした方のリポジトリを編集したり, コミットを追加したり, ログや履歴を調べたりすることができる. クローンしたリポジトリは, 全ての含んだ完全なものである.
